

---

### 1. **Сортировка выбором (Selection Sort)**  
На каждом шаге ищется минимальный элемент в неотсортированной части массива и меняется местами с первым элементом этой части.  
**Временная сложность:** **O(n²)** — во всех случаях (лучшем, среднем, худшем).

---

### 2. **Сортировка обменом / пузырьком (Bubble Sort)**  
Многократно проходит по массиву, сравнивая соседние элементы и меняя их местами, если они стоят в неправильном порядке; наибольший элемент «всплывает» в конец на каждом проходе.  
**Временная сложность:**  
- Худший/средний: **O(n²)**  
- Лучший (с оптимизацией): **O(n)**

---

### 3. **Сортировка вставками (Insertion Sort)**  
Постепенно строит отсортированную часть массива: каждый новый элемент вставляется на своё место среди уже отсортированных.  
**Временная сложность:**  
- Худший/средний: **O(n²)**  
- Лучший (массив уже отсортирован): **O(n)**

---

### 4. **Сортировка слиянием (Merge Sort)**  
Рекурсивно делит массив пополам до одиночных элементов, затем сливает отсортированные подмассивы обратно в один отсортированный массив.  
**Временная сложность:** **O(n log n)** — во всех случаях.

---

### 5. **Сортировка Шелла (Shell Sort)**  
Модификация сортировки вставками: сначала сортирует элементы на расстоянии `gap`, постепенно уменьшая `gap` до 1.  
**Временная сложность:**  
- Зависит от последовательности шагов:  
  - Классическая (`n/2, n/4, …`): **O(n²)**  
  - Улучшенные последовательности: до **O(n log² n)**

---

### 6. **Быстрая сортировка (Quick Sort)**  
Выбирает опорный элемент, разделяет массив на две части (меньше/больше опорного), затем рекурсивно сортирует подмассивы.  
**Временная сложность:**  
- Средний случай: **O(n log n)**  
- Худший случай (плохой выбор опоры): **O(n²)**  
- Лучший случай: **O(n log n)**

---

### 7. **Пирамидальная сортировка (Heap Sort)**  
Строит max-heap из массива, затем последовательно извлекает максимальный элемент и помещает его в конец массива, восстанавливая кучу.  
**Временная сложность:** **O(n log n)** — во всех случаях.

---

### 8. **Последовательный (линейный) поиск**  
Проходит по элементам массива по порядку, сравнивая каждый с искомым значением, пока не найдёт совпадение или не достигнет конца.  
**Временная сложность:** **O(n)** — во всех случаях.

---

### 9. **Бинарный (двоичный) поиск**  
Работает только на отсортированном массиве: на каждом шаге делит диапазон поиска пополам и отбрасывает половину, где искомого элемента точно нет.  
**Временная сложность:** **O(log n)**

---

### 10. **Интерполирующий поиск**  
Использует формулу линейной интерполяции для предсказания позиции искомого элемента в **равномерно распределённом отсортированном массиве**.  
**Временная сложность:**  
- Средний (равномерное распределение): **O(log log n)**  
- Худший (неравномерное): **O(n)**

---

### 11. **Поиск по Фибоначчи**  
Аналог бинарного поиска, но делит массив не пополам, а в пропорциях чисел Фибоначчи; использует только сложения и вычитания.  
**Временная сложность:** **O(log n)**

---
