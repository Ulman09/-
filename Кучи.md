# Аналитический отчет: кучи и хеш-таблицы

## 1. Определения структур данных

### Кучи

**Бинарная куча** - полное бинарное дерево в виде массива с свойством кучи (родитель меньше/больше детей). Представляет собой единое дерево, где добавление нового элемента происходит в конец с последующим "поднятием" вверх, а извлечение минимального элемента сопровождается заменой корня последним элементом и его "опусканием" вниз.

**Биномиальная куча** - набор биномиальных деревьев разного порядка. Поддерживает эффективное слияние куч. Формируется путем вставки (создание новой кучи с одним элементом и объединение с основной) и слияния списков корней двух куч.

**Куча Фибоначчи** - набор деревьев произвольной структуры. Обеспечивает амортизированно постоянное время для вставки и уменьшения ключа. Ключевые операции включают простую вставку элемента, слияние куч и удаление минимума с последующей реструктуризацией.

**Хеш-таблица** - структура, отображающая ключи в значения через хеш-функцию. В отличие от куч, не формируется как дерево, а реализуется на основе массивов и односвязных списков, где каждый элемент хранится по адресу, вычисляемому на основе ключа. Коллизии решаются методом цепочек или открытой адресации.

## 2. Особенности формирования куч

Все три кучи реализуют "очередь с приоритетом", но с разной эффективностью:

- **Бинарная** - простейшая единое дерево с операциями подъема и спуска элементов
- **Биномиальная** - набор деревьев фиксированного размера для эффективного слияния
- **Фибоначчи** - деревья произвольной формы для лучшей амортизированной сложности операций

## 3. Реализация на языках программирования

### Бинарная куча

**Python**: 
```python
import heapq
heap = []
heapq.heapify([8, 3, 5, 1, 6, 2, 4, 7])
heapq.heappush(heap, element)
min_element = heapq.heappop(heap)
```

**C++**: 
```cpp
#include <queue>
#include <vector>
std::priority_queue<int> heap;
std::vector<int> vec = {8, 3, 5, 1, 6, 2, 4, 7};
// Ручная реализация операций добавления и извлечения
```

**Java**:
```java
import java.util.PriorityQueue;
PriorityQueue<Integer> heap = new PriorityQueue<>();
// Ручная реализация на основе массива с операциями вставки и извлечения
```

### Биномиальная куча
(Требует ручной реализации во всех языках)

**Python, C++, Java**: Классы с узлами и деревьями, реализующие операции вставки, объединения и извлечения минимума через слияние списков корней.

### Куча Фибоначчи
(Сложная ручная реализация)

**Python, C++, Java**: Классы с указателями/ссылками между узлами, поддерживающие операции insert(), unite(), getMin(), extractMin(), decreaseKey(), deleteElement().

### Хеш-таблицы

**Python**:
```python
hash_table = {}
hash_table['Alice'] = 'January'
value = hash_table.get('Alice')
del hash_table['Bob']
```

**C++**:
```cpp
#include <unordered_map>
std::unordered_map<std::string, int> umap;
umap["Apple"] = 10;
int value = umap["Apple"];
```

**Java**:
```java
import java.util.HashMap;
HashMap<String, Integer> hashMap = new HashMap<>();
hashMap.put("John", 25);
Integer value = hashMap.get("John");
hashMap.remove("Jim");
```

## 4. Выводы

Все рассмотренные структуры данных представляют различные подходы к организации информации:

- **Кучи** обеспечивают эффективную работу с приоритетами, демонстрируя эволюцию от простой бинарной к сложной but эффективной куче Фибоначчи
- **Хеш-таблицы** решают задачу быстрого доступа по ключу, используя принципиально другой подход на основе хеширования

Различия в реализации между языками отражают их философию:
- **Python** предлагает максимальную простоту встроенных решений
- **C++** обеспечивает контроль над памятью и производительностью
- **Java** находит баланс между простотой использования и строгой типизацией

Семантика операций остается единой across языков, что облегчает перенос знаний и навыков между различными экосистемами программирования.
